<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Lesson 12 - Base Systems</title>
  <link rel="stylesheet" href="assets/style.css">
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" type="text/javascript"></script>
  <style>
    .place-value-table {
      border-collapse: collapse;
      margin: 1em 0;
      display: inline-block;
    }
    .place-value-table td {
      border: 1px solid #ccc;
      padding: 0.5em;
      text-align: center;
      min-width: 40px;
    }
    .place-value-table .header {
      background-color: #f0f0f0;
      font-weight: bold;
    }
    .binary-addition {
      border-collapse: collapse;
      margin: 1em 0;
    }
    .binary-addition td {
      padding: 0.3em 0.5em;
      text-align: center;
      border-bottom: 1px solid #eee;
    }
    .carry-row {
      font-size: 0.8em;
      color: #666;
    }
    .hex-table {
      border-collapse: collapse;
      margin: 1em 0;
      font-size: 0.9em;
    }
    .hex-table td {
      border: 1px solid #ccc;
      padding: 0.3em;
      text-align: center;
    }
    .flowchart {
      background-color: #f8f9fa;
      border: 1px solid #a2a9b1;
      border-radius: 5px;
      padding: 1em;
      margin: 1em 0;
    }
    .step {
      margin: 0.5em 0;
      padding-left: 1em;
      border-left: 3px solid #36c;
    }
  </style>
</head>

<body>
<header id="title-block-header">
<h1 class="title">Base Systems</h1>
</header>

<!-- Table of Contents -->
<nav class="toc">
<ol id="toc">
  <li><a href="#introduction">Introduction</a></li>
  <li><a href="#binary-representations">Binary Representations</a></li>
  <li><a href="#conversion-algorithms">Conversion Algorithms</a>
    <ol>
      <li><a href="#binary-to-decimal">Binary to Decimal</a></li>
      <li><a href="#decimal-to-binary">Decimal to Binary</a></li>
    </ol>
  </li>
  <li><a href="#other-bases">Other Bases: Octal and Hexadecimal</a></li>
  <li><a href="#binary-arithmetic">Binary Arithmetic</a></li>
  <li><a href="#data-representation">Data Representation</a></li>
  <li><a href="#big-oh-growth">Growth of Functions and Big Oh</a></li>
</ol>
</nav>

<main>
<!--Rest of the Body-->
<!-- MAIN CONTENT -->

<section id="introduction">
<h2>1. Introduction</h2>
<p>The usual, decimal number system is the "base 10" number system. Numbers are expressed in terms of powers of 10: the number 3125 refers to the number \(3×10^3 + 1×10^2 + 2×10^1 + 5×10^0\). We need the 10 symbols of 0, 1, 2, 3, 4, 5, 6, 7, 8, and 9, and all numbers can be represented using this decimal number system. These symbols are, of course, referred to as digits. But, this is important: there is absolutely nothing special about the number 10.</p>

<div class="place-value-table">
  <table>
    <tr class="header">
      <td>\(10^3\)</td>
      <td>\(10^2\)</td>
      <td>\(10^1\)</td>
      <td>\(10^0\)</td>
    </tr>
    <tr>
      <td>3</td>
      <td>1</td>
      <td>2</td>
      <td>5</td>
    </tr>
    <tr>
      <td>1000</td>
      <td>100</td>
      <td>10</td>
      <td>1</td>
    </tr>
  </table>
</div>

<p><strong>Quick Check:</strong> What is the value of the digit '2' in the number 5,247?</p>
<details>
<summary>Click for answer</summary>
<p>The digit '2' represents \(2 \times 10^2 = 200\).</p>
</details>
</section>

<section id="binary-representations">
<h2>2. Binary Representations</h2>
<p>In a computer, numbers are represented using electrical states of either "on" or "off". These two states can be represented with the symbols 0 and 1: and so computers can represent numbers in a "base 2" system. We call this the binary number system. The symbols 0 and 1 are referred to as bits, which means "binary digits".</p>

<p>Similar to the decimal system, numbers in binary are expressed in terms of powers of 2: the number 101101 refers to the number \(1 × 2^5 + 0 × 2^4 + 1 × 2^3 + 1 × 2^2 + 0 × 2^1 + 1 × 2^0\), which is 45 in the decimal system.</p>

<div class="place-value-table">
  <table>
    <tr class="header">
      <td>\(2^5\)</td>
      <td>\(2^4\)</td>
      <td>\(2^3\)</td>
      <td>\(2^2\)</td>
      <td>\(2^1\)</td>
      <td>\(2^0\)</td>
    </tr>
    <tr>
      <td>1</td>
      <td>0</td>
      <td>1</td>
      <td>1</td>
      <td>0</td>
      <td>1</td>
    </tr>
    <tr>
      <td>32</td>
      <td>16</td>
      <td>8</td>
      <td>4</td>
      <td>2</td>
      <td>1</td>
    </tr>
  </table>
</div>

<p>To distinguish between numbers written in binary and in other systems like decimal, we use the subscript 2 to denote binary, and 10 to denote decimal. For example: \(100_2 = 4_{10}\).</p>

<p><strong>Examples:</strong></p>
<ul>
  <li>The number 11, in binary, equals 3 in decimal.</li>
  <li>100, in binary, equals 4 in decimal.</li>
  <li>111, in binary, equals 7 in decimal. (Why? 111 = 1 × 4 + 1 × 2 + 1 × 1)</li>
  <li>1000, in binary, equals 8 in decimal.</li>
  <li>1111, in binary, equals 15 in decimal \(1 × 8 + 1 × 4 + 1 × 2 + 1 × 1 = 15\)</li>
  <li>10000 in binary equals 16 in decimal.</li>
</ul>

<p><strong>Quick Check:</strong> What decimal number is represented by \(1101_2\)?</p>
<details>
<summary>Click for answer</summary>
<p>\(1101_2 = 1×8 + 1×4 + 0×2 + 1×1 = 8 + 4 + 0 + 1 = 13_{10}\)</p>
</details>
</section>

<section id="conversion-algorithms">
<h2>3. Conversion Algorithms</h2>

<section id="binary-to-decimal">
<h3>3.1 Binary to Decimal</h3>
<p>To convert from binary to decimal count the number of bits, and, going right to left, label the bits as representing the place values (using increasing powers of 2). Then add up the powers of 2 that have a "1" in their column.</p>

<p>There is another, somewhat clever algorithm that goes from "left to right":</p>

<div class="flowchart">
  <p><strong>Left-to-Right Algorithm:</strong></p>
  <div class="step">Start at the leftmost bit.</div>
  <div class="step">Whenever you see a 1, add a 1 to your current number.</div>
  <div class="step">Every time you move to the right one place, double your number.</div>
  <div class="step">Continue the above two steps until you run out of bits to check.</div>
  <div class="step">When you run out of bits, you are done.</div>
</div>

<p><strong>Example:</strong> let's look at the number \(1010_2\).</p>
<ul>
  <li>Starting at the leftmost bit, we see a 1, so our number is now 1.</li>
  <li>Move to the right: double it, so our number is now 2.</li>
  <li>We see a 0: our number is still 2.</li>
  <li>Move to the right: double it, so our number is now 4.</li>
  <li>We see a 1: add 1, so our number is now 5.</li>
  <li>Move to the right: double it, our number is now 10.</li>
  <li>We see a 0: our number is now 10.</li>
  <li>We run out of bits: so our number is \(10_{10}\).</li>
</ul>
</section>

<section id="decimal-to-binary">
<h3>3.2 Decimal to Binary</h3>
<p>Converting to binary is a little more challenging. Before we do this, let's recall some easy facts about our usual, decimal system:</p>
<ul>
  <li>If you take a number \(n\), written in base 10, and multiply it by ten, you only need to add a zero at the end of the representation. ie \(234 \times 10 = 2340\).</li>
  <li>Conversely, if you divide a number \(n\) by ten (ignoring remainder), you just cut off the last digit: \(234 \, \text{div} \, 10 = 23\).</li>
  <li>A number is a multiple of ten if and only if its last digit is zero.</li>
</ul>

<p>Binary is similar: if we know how to write a number in binary, then if we divide that number by two, we just cut off the last bit. If we multiply that number by two, we just tack on a zero at the end. And lastly, a number is a multiple of two if and only if its last bit is a zero.</p>

<p>We can use these facts and work backwards to figure out the binary representation of a number. First I'll start with a number in binary: \(1011_{2}\). This is equal to \(11_{10}\). It's odd, since the last bit is 1. Divide it by 2: \(1011_{2}\div 2=101_{2}\) (or \(5_{10}\)). This is odd, its last bit is 1. Divide it by 2: \(101_{2}\div 2=10_{2}\) (or \(2_{10}\)). This is even, its last bit is 0. Divide it by 2: \(10_{2}\div 2=1_{2}\) (or just 1). Now we're done.</p>

<p>Notice that every time we divide the number by 2, the binary representation changes by just cutting off the last bit. We can use this to help us figure out the binary representation in the first place: repeatedly divide the number by 2 and write down the remainders. Let's look at the number \(12_{10}\):</p>

<p>\[12 \div 2 = 6\ r0\] \[6 \div 2 = 3\ r0\] \[3 \div 2 = 1\ r1\] \[1 \div 2 = 0\ r1\]</p>

<p>Now that we've gotten to 0, we just read off the remainders in reverse order. So \(12_{10}=1100_{2}\). You can verify that this is correct on your own.</p>

<p>So the steps for converting a number from decimal to binary:</p>
<ul>
  <li>Start at the rightmost output bit.</li>
  <li>Check if the number is even or odd. If it's even, write down a 0, if it's odd, write a 1.</li>
  <li>Divide the number by 2 and move to the left.</li>
  <li>Repeat the previous two steps until the number you're checking is now 0.</li>
</ul>

<p><strong>Exercise</strong> Convert the following numbers to binary:</p>
<ol>
  <li>15</li>
  <li>16</li>
  <li>17</li>
  <li>18</li>
  <li>19</li>
  <li>20</li>
</ol>

<details>
<summary>Click for answers</summary>
<p>
  <ol>
    <li>\(15_{10} = 1111_2\)</li>
    <li>\(16_{10} = 10000_2\)</li>
    <li>\(17_{10} = 10001_2\)</li>
    <li>\(18_{10} = 10010_2\)</li>
    <li>\(19_{10} = 10011_2\)</li>
    <li>\(20_{10} = 10100_2\)</li>
  </ol>
</p>
</details>

<h4>Alternative Algorithm</h4>
<p>Another algorithm to convert a number \( n \) to binary:</p>
<ul>
  <li>Find the largest power of 2 less than (or equal to) \( n \). Put a 1 in that column.</li>
  <li>Subtract that power of 2 from \( n \) and repeat the above step.</li>
  <li>Fill in 0s for all missing powers of 2.</li>
</ul>

<p>For example, look at the number \( 105_{10} \)</p>
<ul>
  <li>The largest power of 2 less than 105 is 64 (\( 2^6 \))</li>
  <li>\( 105 - 64 = 41 \)</li>
  <li>The largest power of 2 less than 41 is 32 (\( 2^5 \)).</li>
  <li>\( 41 - 32 = 9 \)</li>
  <li>The largest power of 2 less than 9 is 8 (\( 2^3 \)).</li>
  <li>\( 9 - 8 = 1 \).</li>
  <li>The largest power of 2 less than or equal to 1 is 1 (\( 2^0 \)).</li>
  <li>\( 1 - 1 = 0 \), so we're done.</li>
</ul>

<p>That means we need 1's in the \( 2^6, 2^5, 2^3 \), and \( 2^0 \) columns: \( 105_{10} = 1101001_2 \).</p>
</section>
</section>

<section id="other-bases">
<h2>4. Other Bases: Octal and Hexadecimal</h2>
<p>Very similarly to base 2 (binary) and base 10 (decimal), we can represent numbers in <strong>octal</strong> (base 8) and <strong>hexadecimal</strong> (base 16). In general, for a base \( b \), we have powers of \( b \) as the "place values", and we need \( b \) symbols to represent numbers from 0 to \( b - 1 \):</p>

<p>Octal uses powers of 8 as its place values, and the symbols 0 through 7 as its "octal digits". Hexadecimal uses powers of 16 as its place values, and the symbols 0 through 9, A, B, C, D, E, and F as its "hex" digits. A represents 10, B is 11, C is 12, D is 13, E is 14, and F is 15.</p>

<h3>Hex / Octal to Decimal</h3>
<p>Similar to converting numbers from binary to decimal, we can convert from hexadecimal or octal to decimal just using the place value algorithm:</p>
<ul>
  <li>\( 271_8 \) is \( 2 \times 64 + 7 \times 8 + 1 = 185_{10} \)</li>
  <li>\( A3_{16} \) is \( 10 \times 16 + 3 = 163_{10} \)</li>
  <li>\( 1A1_{16} \) is \( 1 \times 256 + 10 \times 16 + 1 = 417_{10} \)</li>
  <li>\( 6000_8 \) is \( 6 \times 8^3 = 3072_{10} \)</li>
</ul>

<p><strong>Exercise:</strong> Convert the following numbers to decimal:</p>
<ol>
  <li>\( 2121_{8} \)</li>
  <li>\( 23_{16} \)</li>
  <li>\( AF_{16} \)</li>
  <li>\( FF_{16} \)</li>
</ol>

<details>
<summary>Click for answers</summary>
<p>
  <ol>
    <li>\( 2121_{8} = 2×512 + 1×64 + 2×8 + 1 = 1105_{10} \)</li>
    <li>\( 23_{16} = 2×16 + 3 = 35_{10} \)</li>
    <li>\( AF_{16} = 10×16 + 15 = 175_{10} \)</li>
    <li>\( FF_{16} = 15×16 + 15 = 255_{10} \)</li>
  </ol>
</p>
</details>

<h3>Binary to/from Octal/Hex</h3>
<p>To convert between binary and hexadecimal, we could take a roundabout way of first converting between binary and decimal, and then decimal to hexadecimal. But this is actually much more work than we need to do.</p>

<p>It turns out that there is a very simple algorithm to convert numbers between binary and octal or hex: one "octal digit" represents three bits, and one "hex" digit represents four bits.</p>

<p><strong>Why does this work?</strong> Because \(8^1 = 2^3\) and \(16^1 = 2^4\). The bases are powers of 2, so we can group bits accordingly.</p>

<p><strong>Example:</strong></p>
<ul>
  <li>\(11101011_{2}\): in hex, we look at each group of 4 bits individually starting from the right
    <ul>
      <li>\(1110_{2}=14_{10}\), which is E in hex.</li>
      <li>\(1011_{2}=11_{10}\), which is B in hex.</li>
      <li>So \(11101011_{2}=EB_{16}\)</li>
      <li>\(EB_{16}\) represents \(14\times 16+11=235_{10}\)</li>
    </ul>
  </li>
  <li>What about in octal? Add 0s on the left to look at three bits at a time. So instead of \(11101011_{2}\) we write it as \(011101011_{2}\)
    <ul>
      <li>\(011_{2}=3\)</li>
      <li>\(101_{2}=5\)</li>
      <li>\(011_{2}=3\)</li>
      <li>So \(11101011_{2}=353_{8}\) (Note: corrected from original notes)</li>
      <li>\(353_{8}=3\times 64+5\times 8+3=235_{10}\)</li>
    </ul>
  </li>
</ul>

<p>Now let's convert from hex to binary:</p>
<ul>
  <li>\(AF_{16}\): convert each hex digit into 4 bits individually:
    <ul>
      <li>\(A\) represents ten, which is \(1010_2\)</li>
      <li>\(F\) represents fifteen which is \(1111_2\)</li>
      <li>So \(AF_{16} = 10101111_2\)</li>
    </ul>
  </li>
</ul>

<p>In general, converting between hex and binary requires you to know the conversion table just for each individual hex digit:</p>

<table class="hex-table">
  <tr><td>\(0 \mapsto 0000\)</td><td>\(8 \mapsto 1000\)</td></tr>
  <tr><td>\(1 \mapsto 0001\)</td><td>\(9 \mapsto 1001\)</td></tr>
  <tr><td>\(2 \mapsto 0010\)</td><td>\(A \mapsto 1010\)</td></tr>
  <tr><td>\(3 \mapsto 0011\)</td><td>\(B \mapsto 1011\)</td></tr>
  <tr><td>\(4 \mapsto 0100\)</td><td>\(C \mapsto 1100\)</td></tr>
  <tr><td>\(5 \mapsto 0101\)</td><td>\(D \mapsto 1101\)</td></tr>
  <tr><td>\(6 \mapsto 0110\)</td><td>\(E \mapsto 1110\)</td></tr>
  <tr><td>\(7 \mapsto 0111\)</td><td>\(F \mapsto 1111\)</td></tr>
</table>

<p><strong>Exercises:</strong> Convert these numbers to binary:</p>
<ol>
  <li>\( ABBA_{16} \)</li>
  <li>\( FFFF_{16} \)</li>
  <li>\( 377_{8} \)</li>
  <li>\( 200000_{8} \)</li>
</ol>

<details>
<summary>Click for answers</summary>
<p>
  <ol>
    <li>\( ABBA_{16} = 1010\;1011\;1011\;1010_2 \)</li>
    <li>\( FFFF_{16} = 1111\;1111\;1111\;1111_2 \)</li>
    <li>\( 377_{8} = 011\;111\;111_2 = 11111111_2 \)</li>
    <li>\( 200000_{8} = 010\;000\;000\;000\;000\;000_2 = 10000000000000000_2 \)</li>
  </ol>
</p>
</details>
</section>

<section id="binary-arithmetic">
<h2>5. Binary Arithmetic</h2>
<p>As we've mentioned, numbers are represented in computers in binary, using two states of electricity ("on" or "off", or "high" or "low" voltage) to represent 0s and 1s. But how do computers actually compute anything? We won't get into digital logic in this class, but the addition and multiplication algorithms are quite simple.</p>

<h3>Addition</h3>
<p>Adding numbers in binary is similar to our traditional algorithm for adding decimals: just add them bitwise, carrying 1s if you need to. In other words, the only tricky case is \( 1_2 + 1_2 = 10_2 \).</p>

<p><strong>Example:</strong> Add \( 1011_2 + 1010_2 \):</p>

<table class="binary-addition">
  <tr class="carry-row">
    <td></td><td>1</td><td>1</td><td></td><td></td>
  </tr>
  <tr>
    <td></td><td>1</td><td>0</td><td>1</td><td>1</td>
  </tr>
  <tr>
    <td>+</td><td>1</td><td>0</td><td>1</td><td>0</td>
  </tr>
  <tr style="border-top: 1px solid black;">
    <td></td><td>1</td><td>0</td><td>1</td><td>0</td><td>1</td>
  </tr>
</table>

<p><strong>Exercise:</strong> Add the following numbers, making sure to carry:</p>
<ul>
  <li>\( 111_2 + 1_2 \)</li>
  <li>\( 101_2 + 10_2 \)</li>
  <li>\( 1001_2 + 11_2 \)</li>
</ul>

<details>
<summary>Click for answers</summary>
<p>
  <ul>
    <li>\( 111_2 + 1_2 = 1000_2 \)</li>
    <li>\( 101_2 + 10_2 = 111_2 \)</li>
    <li>\( 1001_2 + 11_2 = 1100_2 \)</li>
  </ul>
</p>
</details>

<h3>Multiplication</h3>
<p>Multiplication can also be done similarly to the standard multiplication algorithm. However, in binary it's even easier, since the only numbers we have to worry about multiplying are 1s and 0s, and these are really easy to multiply.</p>

<p><strong>Algorithm:</strong></p>
<ul>
  <li>Say we are multiplying \( a \times b \), with the bits of \( b \) are \( b_0, \ldots, b_n \). That is: \( b = b_0 + b_1 \cdot 2 + \ldots + b_n \cdot 2^n \).</li>
  <li>For each \( i \) from 0 to \( n \):
    <ul>
      <li>If \( b_i = 1 \), then multiply \( a \times 2^i \) (add \( i \) zeros at the end of the representation of \( a \)), and keep track of this as our \( i \)-th partial product, call it \( p_i \).</li>
      <li>If \( b_i = 0 \), then \( a \times 0 = 0 \) and \( p_i = 0 \).</li>
    </ul>
  </li>
  <li>At the end: add \( p_0 + p_1 + \ldots + p_n \).</li>
</ul>

<p><strong>Example:</strong> Let's multiply \( 1011 \times 1010 \)</p>
<ul>
  <li>The only bits we have to worry about are in the \( 2^1 \) and \( 2^3 \) positions</li>
  <li>\( 1011 \times 2^1 = 10110 \)</li>
  <li>\( 1011 \times 2^3 = 1011000 \)</li>
  <li>Add \( 10110 + 1011000 = 1101110 \)</li>
</ul>
</section>

<section id="data-representation">
<h2>6. Data Representation</h2>
<p>All data is represented in a computer using binary numbers. This includes integers, decimals, images, colors, text, etc. We will not get into how all of these are represented using binary, but I do want to talk a bit about storage and how many objects can be represented in different amounts of storage.</p>

<p>One <strong>byte</strong> is 8 bits of data. As we know from counting principles, there are \( 2^8 \), or \( 256 \), different numbers that can be represented using 8 bits. But of course, we could represent other things: old computers (circa late 80s / early 90s) that only had "8 bit graphics" could only display 256 different colors. Those computers would represent a color using a single byte.</p>

<p>But let's stick to numbers for now: if we represent the numbers using the usual binary representation, 00000000 represents the number 0, 00000001 represents the number 1, etc until we get to 11111111, which represents the number 255. That is: with one byte of data, we can represent the numbers from 0 to 255 (those are the 256 different numbers we can represent: the 255 numbers from 1 to 255, plus the number 0).</p>

<p>What if we want to represent negative numbers? Again, we can only represent 256 numbers using 8 bits, and so if we wanted negatives, we could roughly split that 256 in half between positives and negatives. I say "roughly", because we also need to represent 0. Usually what is done is that 8 bits would represent the numbers from -128 to 127: half the numbers we represent are negative, and the other half are 0 or positive, and so we can represent one more negative than positive. This is typically done using a system called <strong>Two's Complement</strong>.</p>

<p>What if we had more bits? In the Java programming language, an int is a data type <strong>int</strong> representing integers. <strong>ints</strong> are represented by 4 bytes, or 32 bits. That means there are \( 2^{32} \), or over 4 billion different integers that can be represented. Half of those, or \( 2^{31} \) would be negative, and the other half would be 0 or positive. That is: the range of integers represented in Java by an int is the numbers from \(-2^{31}\) to \( 2^{31} - 1\).</p>

<h3>Data Sizes</h3>
<p>The standard metric prefixes:</p>
<ul>
  <li>1 byte = 8 bits</li>
  <li>1 kilobyte (KB) = 1000 bytes</li>
  <li>1 megabyte (MB) = 1,000,000 bytes</li>
  <li>1 gigabyte (GB) = \(10^{9}\) bytes (1 billion bytes)</li>
  <li>1 terabyte (TB) = \(10^{12}\) bytes</li>
</ul>

<p>Historically, data was kept in powers of 2 amounts, which causes some confusion: sometimes "1 KB" means 1024 bytes (\(2^{10}\)), not 1000 bytes. The SI system now uses the prefixes "kibi" (KiB), "mebi" (MiB), "gibi" (GiB), and "tebi" (TiB) to refer to \(2^{10}\), \(2^{20}\), \(2^{30}\), and \(2^{40}\) respectively. Notice that \(2^{10}\approx 1000\), \(2^{20}\approx 1,000,000\), and \(2^{30}\approx 1,000,000,000\).</p>

<h3>Lengths of Representations</h3>
<p>Suppose I give you a number \(n\), written in decimal. How many bits would it take to represent that number? Let's go through a couple of specific examples first:</p>
<ul>
  <li>The number 100 can be represented as \(64\,+\,32\,+\,4\), or \(1100100_{2}\), which has 7 bits.</li>
  <li>The number 200 can be represented as \(128\,+\,64\,+\,8\), or \(11001000_{2}\), which has 8 bits.</li>
</ul>

<p>Let's try some bigger numbers:</p>
<ul>
  <li>The number 1000 can be represented as \(512\,+\,256\,+\,128\,+\,64\,+\,8\), or \(1111001000_{2}\), which has 10 bits.</li>
  <li>The number 2000 can be represented as \(1024\,+\,512\,+\,256\,+\,128\,+\,16\), or \(11110010000_{2}\), which has 11 bits.</li>
</ul>

<p>The pattern is that doubling a number increases its length, in binary, by only a single bit. This is the inverse of the pattern we have seen before: increasing the number of bits by one doubles the amount of numbers you can represent. In other words, if, with \(n\) bits, we can represent \(2^{n}\) numbers, then if we have a number \(n\), we need <strong>about</strong>\(\log_{2}(n)\) bits to represent it. (Notice that the rules of logarithms tell us that \(\log_{2}(2n)=\log_{2}(2)+\log_{2}(n)\), which is \(\log_{2}(n)+1\).)</p>

<p>I say "about" in the previous paragraph for technical reasons:</p>
<ul>
  <li>\(\log_{2}(64)=6\), but the number 64 is written as \(1000000_{2}\), that is, it has 7 bits.</li>
  <li>\(\log_{2}(63)\approx 5.977\), but the number 63 is written as \(111111_{2}\), which has 6 bits.</li>
  <li>\(\log_{2}(65)\approx 6.022\), but the number 65 is written as \(1000001_{2}\), which has 7 bits.</li>
</ul>

<p>In general, the number \(2^{n}\) takes n+1 bits to write. All numbers between \(2^{n}\) and \(2^{n+1}\), not including \(2^{n+1}\), will need \(n+1\) bits. That means that the formula for finding the number of bits to represent a number \(n\) is \(\lfloor\log_{2}(n)\rfloor+1\), where the function \(\lfloor x\rfloor\) outputs the greatest integer less than or equal to \(x\). In other words, if \(k\) is an integer such that \(k\leq\log_{2}(n)<k+1\), then \(n\) takes \(k+1\) bits to write in binary.</p>

<p><strong>Quick Check:</strong> How many bits are required to represent the decimal number 500?</p>
<details>
<summary>Click for answer</summary>
<p>\(\log_{2}(500) \approx 8.966\), so \(\lfloor 8.966 \rfloor + 1 = 8 + 1 = 9\) bits. Indeed, \(500_{10} = 111110100_2\), which has 9 bits.</p>
</details>
</section>

<section id="big-oh-growth">
<h2>7. Growth of Functions and Big Oh</h2>
<p><strong>Example: UNIX Time</strong></p>
<ul>
  <li>UNIX systems originally store time as a <strong>signed 32-bit integer</strong>
    <ul>
      <li>Seconds after the "epoch" January 1 1970 (00:00:00 UTC)</li>
      <li>Signed 32 bits: 1 bit for \(\pm\), 31 bits for data</li>
      <li>Maximum value: \(2^{31}-1\)= 2,147,483,647.</li>
      <li>2,147,483,647 seconds \(\approx\) 68 years.</li>
      <li>Integer overflow on January 19, 2038 at 03:14:07</li>
    </ul>
  </li>
  <li>Solution? Use more bits (not always a solution, but ok)</li>
</ul>

<p><strong>64-bit time</strong></p>
<ul>
  <li><strong>signed 64-bit integers</strong>: maximum value \(2^{63}-1\approx 9\times 10^{18}\)</li>
  <li>Or \(\approx\) 290 billion years.</li>
  <li>Age of the universe \(\approx\) 14 billion years</li>
  <li>Solar system dies in \(\approx\) 7-8 billion years.</li>
</ul>

<p><strong>Moral of the story:</strong> Exponential functions grow "ridiculously fast"! Doubling the number of bits squares the magnitude of the numbers we can represent.</p>

<p>How can we make the statement that exponential functions grow "ridiculously fast" precise? More specifically, how can we say exponential functions grow faster than polynomials? Conversely, how do we express the idea that logarithmic functions grow slower than linear functions?</p>

<p>To formalize the idea that \(2^n\) eventually outgrows \(n^3\), no matter how large the constant factors, mathematicians use a concept called <strong>Big O notation</strong>.</p>

<h3>Big Oh</h3>
<p><strong>Definition</strong>: Let \( f : \mathbb{N} \rightarrow \mathbb{R} \) and \( g : \mathbb{N} \rightarrow \mathbb{R} \). We say \( f \in O(g) \) or, we write \( f(x) = O(g(x)) \) for convenience (this is not an equality in the usual sense; it describes a growth relationship), if there is \( N \in \mathbb{N} \) and a positive real number \( k \) such that for all \( n \geq N \), \( |f(n)| \leq k \cdot |g(n)| \).</p>

<p><strong>Example:</strong> \(f(n) = n^3, \, g(n) = 2^n. \, \text{Claim: } n^3 = O(2^n).\)</p>
<ul>
  <li>\( f(0) = 0, \, g(0) = 1 \)</li>
  <li>\( f(1) = 1, \, g(1) = 2 \)</li>
  <li>\( f(2) = 8, \, g(2) = 4 \)</li>
  <li>\( f(3) = 27, \, g(3) = 8 \)</li>
  <li>...</li>
  <li>\( f(10) = 1000, \, g(10) = 1024 \, \text{Aha!} \)</li>
</ul>

<p>\(\forall n \geq 10(n^3 \leq 2^n)\). Proof? Really what we want to show is: \(\lim_{n \to \infty} \frac{n^3}{2^n} = 0\).</p>

<p>Solution: l'Hopital's rule:</p>
<p>\[\lim_{n \to \infty} \frac{n^3}{2^n} = \lim_{n \to \infty} \frac{3n^2}{\ln(2)2^n}\]</p>
<p>\[= \lim_{n \to \infty} \frac{6n}{\ln(2)\ln(2)2^n} = \lim_{n \to \infty} \frac{6}{\ln(2)\ln(2)\ln(2)2^n}\]</p>
<p>\[= 0\]</p>
</section>

</main>

<div class="footer">
    <p>MAT 3120, Discrete Mathematics - Lesson 12: Base Systems</p>
    <p><a href="#title-block-header">Back to Top ↑</a></p>
</div>
</body>
</html>